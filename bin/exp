#!/usr/bin/env python

from os import listdir
from os.path import isfile, isdir, join, splitext, basename, dirname 
from collections import OrderedDict
import os
import argparse
import subprocess
import commands
import time
import pickle
import signal
import psutil
import shutil
import numpy as np
import types

lanes = 16
bankSize = 32 * 1024 / 4

SPATIAL_HOME = os.environ['SPATIAL_HOME']
PIRL_HOME = os.environ['PIR_HOME']
APP_DIR='{}/apps/src/'.format(SPATIAL_HOME)

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def newAppName(app, args, params):
    postfix = '_'.join([str(a) for a in args])
    postfix = postfix + ''.join(["_{}_{}".format(k,str(params[k])) for k in params ]) 
    newname = '{}_{}'.format(app, postfix)
    newname = newname.replace('.','d')
    return newname

def copyApp(app, args, params):
    path = '{0}/{1}.scala'.format(APP_DIR, app)
    newname = newAppName(app, args, params) 
    if not os.path.exists('{}/gen'.format(APP_DIR)):
        os.makedirs(directory)
    newpath = '{0}/gen/{1}.scala'.format(APP_DIR, newname)
    paramFound = {}
    with open(newpath, 'w') as newapp:
        with open(path, 'r') as origapp :
            for line in origapp:
                found = False
                if 'object {}'.format(app) in line:
                    newapp.write(line.replace(app, newname))
                    found = True
                for param in params:
                    if 'val {} = '.format(param) in line:
                        newapp.write('val {} = {}\n'.format(param, params[param]))
                        paramFound[param] = True
                        found = True
                if not found:
                    newapp.write(line)
    for param in params:
        if param not in paramFound and param!='fpga':
            print('Param {} not found|||!'.format(param))
            exit()

def runApp(app, args, params, regen):
    copyApp(app, args, params)
    newname = newAppName(app, args, params)
    command = "apps/bin/runapp {} {} {}".format(newname, ' '.join([str(a) for a in args]), regen)
    print('command={}'.format(command))
    proc = subprocess.Popen(command.split(), shell=False)
    pid = proc.pid
    time.sleep(1)

def clear(app, args, params, regen):
    newname = newAppName(app, args, params)
    command = "rm -r gen/{}/Top.vcd".format(newname)
    print(command)
    subprocess.call(command, shell=True)

def clearAll():
    dirs = [join('gen', d) for d in listdir('gen') if isdir(join('gen', d))]
    for d in dirs:
        files = [join(d, f) for f in listdir(d) if f != 'sim.log']
        for f in files:
            print('removing {}'.format(f))
            if isdir(f):
                shutil.rmtree(f)
            elif isfile(f):
                os.remove(f)
            
count = 0
def status(app, args, params, regen):
    global count
    newname = newAppName(app, args, params)
    command = "apps/bin/status {}".format(newname)
    print(command)
    proc = subprocess.Popen(command, shell=True)
    proc.wait()
    # time.sleep(0.1)
    raw_input("status[{}]: Press Enter to continue...\n".format(count))
    count += 1
    # proc.kill()

def target(app, args, params, regen):
    if opts.run:
        runApp(app, args, params, regen)
    elif opts.status:
        status(app, args, params, regen)

def dse(app, args, params, regen):
    # print(params)
    for param in params:
        # print('  param:' + param + ' = ' + str(params[param]))
        if type(params[param]) is list:
            if len(params[param])==0:
                return
            newParams = params.copy()
            cnt = 0
            if opts.single:
                params[param] = [params[param][0]]
            for val in params[param]:
                newParams[param] = val
                cnt += dse(app, args, newParams, regen)
            return cnt
        elif type(params[param]) is types.LambdaType:
            newParams = params.copy()
            newParams[param] = params[param](params)
            return dse(app, args, newParams, regen)
        else:
            continue
    print('{}{} args={} and params=[{}]{}'.format(bcolors.OKBLUE, app, str(args),
        ' '.join(['{}={}'.format(p,params[p]) for p in params]), bcolors.ENDC))
    target(app, args, params, regen)
    return 1

def irange(start, stop, step):
    return range(start, stop+step, step)

def TPCHQ6(regen):
    app = 'TPCHQ6'
    params = OrderedDict()
    N = 96000
    args = [N]
    # params['outerPar'] = irange(1, 10, 2) 
    params['outerPar'] = irange(1, 10, 2) 
    params['tileSize'] = lambda params: irange(3000, N/params['outerPar']/4, 3000)
    space = dse(app, args, params, regen)
    print('{} space: {}'.format(app, space))

def expRun():
    #################################################################################################################
    ###                                                ASPLOS 2018                                           ########
    #################################################################################################################

    ### TO RUN        ######################################################################################################
    TPCHQ6(regen='true')

    pass

def main():
    parser = argparse.ArgumentParser(description='Run experiments')
    parser.add_argument('--single', dest='single', action='store_true', default=False) 
    parser.add_argument('--run', dest='run', action='store_true', default=False) 
    parser.add_argument('--status', dest='status', action='store_true', default=False) 
    parser.add_argument('--clearAll', dest='clearAll', action='store_true', default=False) 
    global opts
    (opts, args) = parser.parse_known_args()

    os.chdir(SPATIAL_HOME)

    if opts.clearAll:
        clearAll()
    else:
        expRun()

    #################################################################################################################

if __name__ == "__main__":
    main()

