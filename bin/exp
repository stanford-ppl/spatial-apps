#!/usr/bin/env python

from os import listdir
from os.path import isfile, isdir, join, splitext, basename, dirname 
from collections import OrderedDict
import os
import argparse
import subprocess
import commands
import time
import pickle
import signal
import psutil
import shutil
import numpy as np
import types
import csv

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.ticker as ticker
import os, sys
import math

lanes = 16
bankSize = 32 * 1024 / 4
proc_thresh = 40
max_bw = 12.8*4

SPATIAL_HOME = os.environ['SPATIAL_HOME']
PIR_HOME = os.environ['PIR_HOME']
APP_DIR='{}/apps/src/'.format(SPATIAL_HOME)
JOB_PATH="{}/gen/job_list.pickle".format(SPATIAL_HOME)
SUMMARY_PATH="{}/apps/summary.pickle".format(SPATIAL_HOME)
SUMMARY_CSV_PATH="{}/apps/summary.csv".format(SPATIAL_HOME)
BEST_SUMMARY_CSV_PATH="{}/apps/best.csv".format(SPATIAL_HOME)
apps = ['DotProduct', 'TPCHQ6', 'GDA', 'BlackScholes', 'Kmeans_plasticine', 'PageRank_plasticine', 'SPMV_CRS', 'GEMM_Blocked']
passes=["GEN_PIR","FIT_PIR","GEN_CHISEL","MAKE_VCS","MAP_PIR","RUN_SIMULATION"]
progress_cache = {}
cycle_cache = {}
summary_headers = ['App', 'cycle', 'lavgbw', 'savgbw', 'pcuUtil', 'mcuUtil', 'scuUtil', 'ocuUtil', 'mcUtil', 'ocuUtil', 'mcUtil',
    'slinkUtil', 'vlinkUtil', 'clinkUtil', 'totalRegUtil', 'totalFUUtil', 'totalSBufUtil', 
    'totalVBufUtil']

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def plot():
    cmap = matplotlib.cm.get_cmap('Oranges')
    for app in apps:
        if app==opts.app or opts.app=='ALL':
            for args in summary[app]:
                fig, ax = plt.subplots()
                for fullname in summary[app][args]:
                    tileSize = int(fullname.split('tileSize_')[1].split('_')[0])
                    used, total = summary[app][args][fullname]['pcuUtil']
                    pcu = futil(used, total)
                    used, total = summary[app][args][fullname]['mcuUtil']
                    mcu = futil(used, total)
                    used, total = summary[app][args][fullname]['mcUtil']
                    mc = futil(used, total)
                    lavgbw = summary[app][args][fullname]['lavgbw']
                    cycle = summary[app][args][fullname]['cycle']
                    # sp = ax.scatter(pcu, cycle, c = color_spd, s = dotSize, marker = marker_pd, edgecolors='none')
                    size = mcu * 200
                    # size = mc * 100
                    # size = mc * 100
                    # size = lavgbw
                    # size = tileSize 
                    bw = (lavgbw + 3) / 15
                    color = cmap(bw)
                    # color = cmap(max_bw - lavgbw/max_bw)
                    cycle = float(cycle) / (7.5 * (10 ** 7))
                    if tileSize==16:
                        ec = 'none'
                    else:
                        ec = 'k'
                    sp = ax.scatter(pcu * 100, cycle, c=color, s=size, edgecolors=ec)
                plot_path = '{}/apps/{}_{}.png'.format(SPATIAL_HOME,app, args)
                plt.grid(True)
                plt.xlabel('PCU Utilization (%)')
                plt.ylabel('Runtime')
                ax.set_ylim(0,1)
                fig.set_size_inches(6,4)
                plt.gcf().subplots_adjust(bottom=0.15)
                plt.savefig(plot_path, format='png', dpi=900)
                print('Generate {}'.format(plot_path))

def sargs(args):
    return '_'.join([str(a) for a in args])

def getFullName(app, args, params):
    postfix = sargs(args) 
    postfix = postfix + ''.join(["_{}_{}".format(k,str(params[k])) for k in params ]) 
    if postfix != "":
        fullname = '{}_{}'.format(app, postfix)
    else:
        fullname = app
    fullname = fullname.replace('.','d')
    return fullname

def copyApp(app, args, params):
    path = '{0}/{1}.scala'.format(APP_DIR, app)
    fullname = getFullName(app, args, params) 
    if not os.path.exists('{}/gen'.format(APP_DIR)):
        os.makedirs('{}/gen'.format(APP_DIR))
    newpath = '{0}/gen/{1}.scala'.format(APP_DIR, fullname)
    paramFound = {}
    with open(newpath, 'w') as newapp:
        with open(path, 'r') as origapp :
            for line in origapp:
                found = False
                if 'object {}'.format(app) in line:
                    newapp.write(line.replace(app, fullname))
                    found = True
                for param in params:
                    if 'val {} = '.format(param) in line:
                        newapp.write('val {} = {}\n'.format(param, params[param]))
                        paramFound[param] = True
                        found = True
                if not found:
                    newapp.write(line)
    for param in params:
        if param not in paramFound:
            print('Param {} not found !!!'.format(param))
            exit()

def checkProcess():
    for pid in job_list:
        if not os.path.exists("/proc/{}".format(pid)):
            job_list.remove(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))

def waitProcess():
    checkProcess()
    if len(job_list) > proc_thresh:
        time.sleep(5)
        waitProcess()

def runApp(app, args, params):
    if opts.parallel:
        waitProcess()
        signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    if args or params:
        copyApp(app, args, params)
    fullname = getFullName(app, args, params)
    command = "apps/bin/runapp {} {} {} {}".format(fullname, ' '.join([str(a) for a in args]),
            opts.torun, opts.regen)
    print('command={}'.format(command))
    proc = subprocess.Popen(command.split(), shell=False)
    pid = proc.pid
    job_list.append(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))
    if opts.parallel:
        time.sleep(1)
    else:
        proc.wait()

def clear(app, args, params):
    fullname = getFullName(app, args, params)
    command = "rm -r gen/{}/Top.vcd".format(fullname)
    print(command)
    subprocess.call(command, shell=True)

def clearAll():
    dirs = [join('gen', d) for d in listdir('gen') if isdir(join('gen', d))]
    for d in dirs:
        files = [join(d, f) for f in listdir(d) if f != 'sim.log']
        for f in files:
            print('removing {}'.format(f))
            if isdir(f):
                shutil.rmtree(f)
            elif isfile(f):
                os.remove(f)
            
count = 0
def status(app, args, params):
    global count
    fullname = getFullName(app, args, params)
    command = "apps/bin/status {}".format(fullname)
    print(command)
    proc = subprocess.Popen(command, shell=True)
    proc.wait()
    # raw_input("status[{}]: Press Enter to continue...\n".format(count))
    count += 1
    # proc.kill()

def logs(app, passName):
    if passName=="GEN_PIR":
        return '{}/gen/{}/gen_pir.log'.format(SPATIAL_HOME, app)
    elif passName=="FIT_PIR":
        return '{}/out/{}/fit_pir.log'.format(PIR_HOME,app)
    elif passName=="GEN_CHISEL":
        return '{}/gen/{}/gen_chisel.log'.format(SPATIAL_HOME,app)
    elif passName=="MAKE_VCS":
        return '{}/gen/{}/vcs.log'.format(SPATIAL_HOME,app)
    elif passName=="MAP_PIR":
        return '{}/out/{}/map_pir.log'.format(PIR_HOME,app)
    elif passName=="RUN_SIMULATION":
        return '{}/gen/{}/sim.log'.format(SPATIAL_HOME, app)
    elif passName=="Utilization":
        return '{}/out/{}/ResourceAnalysis.log'.format(PIR_HOME, app)

def grep(path, patterns):
    found = None
    if type(patterns)!=list:
        patterns = [patterns]
    with open(path, 'r') as f:
        for line in f:
            for pattern in patterns:
                if pattern in line:
                    found = line
                    break
    return found

def cycleOf(app):
    if app in cycle_cache:
        return cycle_cache[app]
    log = logs(app, "RUN_SIMULATION")
    line = grep(log, ["Design ran for"])
    if line is None:
        return None
    else:
        cycle = int(line.split("Design ran for ")[1].split(" ")[0])
        cycle_cache[app] = cycle
        return cycle

def progress(app, passName):
    if (app, passName) in progress_cache:
        return progress_cache[(app, passName)]
    log = logs(app, passName)
    prog = "NONE"
    if os.path.exists(log):
        isDone=(grep(log,"{}(DONE)".format(passName)) is not None)
        if isDone:
	    isFailed=grep(log, ['error','Error','ERROR','No rule to make', 'Killed', 'KILLED']) is not None
            if passName=="RUN_SIMULATION":
	        hasCycle=cycleOf(app) is not None
	        timeOut=grep(log, 'Hardware timeout after') is not None
                if not hasCycle or timeOut:
                    isFailed = True
            if isFailed: 
	        prog = "FAILED"
            else:
	        prog = "SUCCESS"
        else:
	    prog = "RUNNING"
    else:
        prog = "NOTRUN"
    progress_cache[(app,passName)] = prog
    return prog

def success(app, passName):
    return progress(app, passName)=="SUCCESS"

def getUtil(line):
    used,total=line.split("Util(")[1].split(')')[0].split(',')
    used = int(used)
    total = int(total)
    return (used, total)

def avgbw(app, args, params):
    lword = 0
    sword = 0
    if 'TPCHQ6' in app:
        N, = args
        lword += N * 4 # load 4 data stucture
    elif 'GDA' in app:
        R = args[0]
        C = 96
        lword += C * 2 # load mu0, mu1
        lword += R # load y
        lword += R * C # load x
        sword += C * C # store sigma
    elif 'BlackScholes' in app:
        N = args[0]
        lword += N * 6 # load 6 data stucture
        sword += N # store optpriceBlk
    elif 'GEMM_Blocked' in app:
        dim = 512
        tileSize = params['tileSize']
        i_tileSize = params['i_tileSize']
        # load b_sram
        lword += (tileSize * tileSize) * (dim / tileSize) * (dim / tileSize) * (dim / i_tileSize)
        # load a_sram
        lword += (tileSize) * (i_tileSize) * (dim / tileSize) * (dim / tileSize) * (dim / i_tileSize)
        # store c_col
        sword += i_tileSize * tileSize * (dim / tileSize) * (dim / i_tileSize)
    elif 'Kmeans_plasticine' in app:
        iters = 1
        D = 96
        K = 20
        N = 6144
        dim = 96
        tileSize = params['tileSize']
        BN = tileSize
        BD = dim
        lword += K * D # load orgCts
        lword += (BN * BD) * (N / BN) * iters # pts
        sword += (K * D) # store centroids
    elif 'PageRank_plasticine' in app:
        # lword += tileSize * 3 * (NP / tileSize) * iters # load initPR, edgesId, edgesLen
        # lword += numEdges * 2 * tileSize * (NP / tileSize) * iters # load edges, counts
        # lword += num2gather * tileSize * (NP / tileSize) * iters # gather
        # sword += tileSize * (NP / tileSize)  * iters # store currentPR
        pass
    elif 'SPMV_CRS' in app:
        MAGIC = 15162342 
        # lword += (tileSize + 1) * (N / tileSize) # load rowid_sram 
        # lword += (stop_id - start_id) * tileSize * 
        simlog = logs(app, "RUN_SIMULATION")
        with open(simlog, 'rb') as f:
            for line in f:
                if "Sum of size (#bursts) of dense loads:" in line:
                    burst = int(line.split(":")[1].split("(")[1].split(")")[0])
                    lword += (burst-MAGIC) * 16
                if "Sum of size (#bursts) of dense stores:" in line:
                    burst = int(line.split(":")[1].split("(")[1].split(")")[0])
                    sword += (burst-MAGIC) * 16
                if "Sparse reads: " in line:
                    lword += int(line.split("(")[1].split(")")[0])  
                if "Sparse write: " in line:
                    sword += int(line.split("(")[1].split(")")[0])  
        pass

    lbyte = lword * 4
    sbyte = sword * 4
    second = float(cycleOf(app)) / (10 ** 9)
    lgbps = lbyte / second / (10 ** 9)
    sgbps = sbyte / second / (10 ** 9)
    return (lgbps, sgbps)

def summarize(app, args, params):
    global summary
    fullname = getFullName(app, args, params)
    # for p in passes:
        # print(p, progress(fullname,p))
    if success(fullname, "MAP_PIR") and success(fullname, "RUN_SIMULATION"):
        if fullname not in summary[app][sargs(args)]:
            print('summarize:{}'.format(fullname))
            summary[app][sargs(args)][fullname] = OrderedDict()
            table = summary[app][sargs(args)][fullname]
            cycle = cycleOf(fullname) 
            table['cycle'] = cycle
            table['lavgbw'], table['savgbw'] = avgbw(fullname, args, params)
            reslog = logs(fullname, "Utilization")
            with open(reslog, 'rb') as f:
                for line in f:
                    for header in summary_headers:
                        if header in line:
                            table[header] = getUtil(line)

def futil(used,total):
   return round(float(used) / float(total), 3)

def bestSummary():
    best = OrderedDict()
    best['TPCHQ6'] = ('TPCHQ6_96000_outerPar_8_tileSize_2000', '96000')
    best['BlackScholes'] = ('BlackScholes_1966080_outerPar_1_tileSize_32768', '1966080')
    best['Kmeans_plasticine'] = ('Kmeans_plasticine_1_6144_tileSize_512', '1_6144')
    best['SPMV_CRS'] = ('SPMV_CRS__tileSize_208_tile_par_2_pt_par_1', '')
    best['GEMM_Blocked'] = ('GEMM_Blocked__tileSize_256_i_tileSize_256_loop_jj_1_loop_ii_1_loop_kk_1_loop_i_4_loop_k_3', '')
    best['GDA'] = ('GDA_38400_tileSize_1600_outerPar_6_midPar_1', '38400')

    headers = ['App', 'lavgbw', 'savgbw', 'pcuUtil', 'mcuUtil', 'mcUtil', 'totalFUUtil']
    with open(BEST_SUMMARY_CSV_PATH, 'w') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=headers)
        writer.writeheader()
        for app in best:
            dict = {'App':app }
            for header in headers:
                fullname, args = best[app]
                if header == 'App':
                    pass
                elif header in ['lavgbw', 'savgbw']:
                    dict[header] = round(summary[app][args][fullname][header] / max_bw * 100, 3)
                elif header not in ['cycle']:
                    used, total = summary[app][args][fullname][header]
                    dict[header] = futil(used, total) * 100
                else:
                    dict[header] = summary[app][args][fullname][header]
            writer.writerow(dict)

def summaryToCsv():
    global summary
    with open(SUMMARY_CSV_PATH, 'w') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=summary_headers)
        writer.writeheader()
        for app in summary:
            for arg in summary[app]:
                for fullname in summary[app][arg]: 
                    dict = {'App':fullname}
                    for header in summary[app][arg][fullname]:
                        if header not in ['App', 'cycle', 'lavgbw', 'savgbw']:
                            used, total = summary[app][arg][fullname][header]
                            dict[header] = futil(used, total)
                        elif header in ['lavgbw', 'savgbw']:
                            dict[header] = round(summary[app][arg][fullname][header], 3)
                        else:
                            dict[header] = summary[app][arg][fullname][header]
                    writer.writerow(dict)


def target(app, args, params):
    if opts.run:
        runApp(app, args, params)
    if opts.status:
        status(app, args, params)
    if opts.summary:
        summarize(app, args, params)

def dse(app, args, params):
    # print(params)
    for param in params:
        # print('  param:' + param + ' = ' + str(params[param]))
        if type(params[param]) is list:
            if len(params[param])==0:
                return 0
            newParams = params.copy()
            cnt = 0
            if opts.single:
                params[param] = [params[param][0]]
            for val in params[param]:
                newParams[param] = val
                cnt += dse(app, args, newParams)
            return cnt
        elif type(params[param]) is types.LambdaType:
            newParams = params.copy()
            newParams[param] = params[param](params)
            return dse(app, args, newParams)
        else:
            continue
    print('{}{} args={} and params=[{}]{}'.format(bcolors.UNDERLINE, app, str(args),
        ' '.join(['{}={}'.format(p,params[p]) for p in params]), bcolors.ENDC))
    target(app, args, params)
    return 1

def irange(start, stop, step):
    r = range(start, stop, step)
    if (len(r)>0):
        last = r[-1]
    else:
        last = start
    if(last+step==stop):
        r.append(stop)
    return r

def addArgs(app, args):
    if opts.summary:
        if sargs(args) not in summary[app]: 
            summary[app][sargs(args)] = OrderedDict()

# tucson
def TPCHQ6():
    app = 'TPCHQ6'
    space = 0
    N = 96000
    args = [N]
    addArgs(app, args)

    # FINISHED
    params = OrderedDict()
    params['outerPar'] = irange(1, 10, 2) 
    params['tileSize'] = lambda params: irange(3000, min(bankSize, N/params['outerPar']/4), 3000)
    space += dse(app, args, params)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(6, 10, 2) 
    params['tileSize'] = lambda params: irange(400, min(bankSize, N/params['outerPar']/4), 800)
    space += dse(app, args, params)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(2, 10, 2) 
    params['tileSize'] = lambda params: irange(16, min(bankSize, N/params['outerPar']/200), 16*2)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# tucson
def GDA():
    app = 'GDA'
    space = 0

    # R = 192000
    # MAXC = 80
    # args = [R]
    # addArgs(app, args)

    # # Finished 
    # params = OrderedDict()
    # # params['tileSize'] = irange(16, 16*5, 16) 
    # params['tileSize'] = irange(16, bankSize*lanes/MAXC, 512) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 
    # space += dse(app, args, params)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(16, 16*3, 16*2) 
    # params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    # params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 
    # space += dse(app, args, params)

    # # portland
    # R = 19200
    # MAXC = 80
    # args = [R]
    # addArgs(app, args)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(1024, bankSize*lanes/MAXC, 1024) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 
    # space += dse(app, args, params)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(1024, bankSize*lanes/MAXC, 1024) 
    # params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    # params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 
    # space += dse(app, args, params)

    R = 38400 
    MAXC = 96
    args = [R]
    addArgs(app, args)
    params = OrderedDict()
    params['tileSize'] = 1600
    params['outerPar'] = 6
    params['midPar'] = 1 
    space += dse(app, args, params)
    print('{} space: {}'.format(app, space))

# london
def GEMM_Blocked():
    app = 'GEMM_Blocked'
    space = 0
    dim = 512
    # args += [dim]
    args = []
    addArgs(app, args)

    params = OrderedDict()
    params['tileSize']   = [16, 256] # irange(16, dim, 16)
    params['i_tileSize'] = [16, 256] # irange(16, dim, 16)
    params['loop_jj']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_ii']    = lambda params: irange(1 , min(dim/params['i_tileSize'], 2), 1)
    params['loop_kk']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_i']     = lambda params: irange(1 , min(params['i_tileSize']    , 2), 1)
    params['loop_k']     = lambda params: irange(1 , min(params['tileSize']      , 2), 1)
    space += dse(app, args, params)

    params = OrderedDict()
    params['tileSize']   = [256] # irange(16, dim, 16)
    params['i_tileSize'] = [256] # irange(16, dim, 16)
    params['loop_jj']    = 1 
    params['loop_ii']    = 1
    params['loop_kk']    = 1
    params['loop_i']     = [1,2,3,4,5]
    params['loop_k']     = [1,2,3,4,5]
    space += dse(app, args, params)
    print('{} space: {}'.format(app, space))

# london
def BlackScholes():
    app = 'BlackScholes'
    space = 0
    N = 1966080  
    args = [N]
    addArgs(app, args)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(1, 4, 1) 
    params['tileSize'] = lambda params: irange(1024, min(bankSize, N/params['outerPar']), 1024)
    space += dse(app, args, params)

    params = OrderedDict()
    params['outerPar'] = 1 
    params['tileSize'] = lambda params: irange(1024*16, min(bankSize*lanes,N/params['outerPar']),1024*16)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

def PageRank_plasticine():
    app = 'PageRank_plasticine'
    space = 0
    iters = 1
    NP = 491520 # 2048 in simulation
    damp = 0.125
    args = [iters, NP, damp]
    addArgs(app, args)

    params = OrderedDict()
    maxTile = min(bankSize*lanes,NP)
    params['tileSize'] = [16, 1024, 1024*6, maxTile/4, maxTile/2, maxTile] 
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# london
def Kmeans_plasticine():
    app = 'Kmeans_plasticine'
    space = 0
    iter = 1
    N = 6144
    dim = 96
    args = [1, N]
    addArgs(app, args)

    # Finished 
    params = OrderedDict()
    params['tileSize'] = irange(16, 16, 1) + irange(128, 512, 128) + irange(1024,min(bankSize*lanes/dim, N), 1024)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# tucson
def SPMV_CRS():
    app = 'SPMV_CRS'
    space = 0
    N = 494
    args = []
    addArgs(app, args)

    params = OrderedDict()
    maxTile = min(bankSize*lanes, N)
    # Finished
    params['tileSize'] = irange(16, maxTile, 64) 
    params['tile_par'] = lambda params: irange(1, min(5, N/params['tileSize']), 1)
    params['pt_par'] = lambda params: irange(1, min(5, params['tileSize']), 1)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

def expRun():
    #################################################################################################################
    ###                                                ASPLOS 2018                                           ########
    #################################################################################################################

    ### TO RUN        ######################################################################################################
    app = opts.app

    if app in ['TPCHQ6', 'ALL']:
        TPCHQ6()
    if app in ['GDA', 'ALL']:
        GDA()
    if app in ['GEMM_Blocked', 'ALL']:
        GEMM_Blocked()
    if app in ['BlackScholes', 'ALL']:
        BlackScholes()
    if app in ['Kmeans_plasticine', 'ALL']:
        Kmeans_plasticine()
    if app in ['PageRank_plasticine', 'ALL']:
        PageRank_plasticine()
    if app in ['SPMV_CRS', 'ALL']:
        SPMV_CRS()

def regression():
    if opts.app=="ALL":
        apps = []
        apps.append("DotProduct")
        apps.append("OuterProduct")
        apps.append("Backprop")
        apps.append("Gibbs_Ising2D")
        apps.append("TPCHQ6")
        apps.append("SPMV_CRS")
        apps.append("BlackScholes")
        # apps.append("Kmeans_plasticine")
        # apps.append("PageRank_plasticine")
        apps.append("GEMM_Blocked")
        apps.append("GDA")
        # apps.append("SYRK_col")
    else:
        apps = [opts.app]

    opts.torun = "GEN_PIR,MAP_PIR"
    for app in apps:
        target(app, [], {})

def main():
    parser = argparse.ArgumentParser(description='Run experiments')
    parser.add_argument('--sequential', dest='parallel', action='store_false', default=True) 
    parser.add_argument('--parallel', dest='parallel', action='store_true', default=True) 
    parser.add_argument('--single', dest='single', action='store_true', default=False) 
    parser.add_argument('--run', dest='run', action='store_true', default=False) 
    parser.add_argument('--status', dest='status', action='store_true', default=False) 
    parser.add_argument('--clearAll', dest='clearAll', action='store_true', default=False) 
    parser.add_argument('--app', dest='app', action='store', default='ALL',help='App name')
    parser.add_argument('--regen', dest='regen', action='store', default='false',
        help='force pass to rerun' )
    parser.add_argument('--torun', dest='torun', action='store', default='ALL',
        help='Pass to run')
    parser.add_argument('--summary', dest='summary', action='store_true', default=False) 
    parser.add_argument('--best', dest='best', action='store_true', default=False) 
    parser.add_argument('--plot', dest='plot', action='store_true', default=False) 
    parser.add_argument('--regression', dest='regression', action='store_true', default=False) 

    global opts
    (opts, args) = parser.parse_known_args()

    os.chdir(SPATIAL_HOME)
    if not os.path.exists('{}/gen'.format(SPATIAL_HOME)):
        os.makedirs('{}/gen'.format(SPATIAL_HOME))
    global job_list
    if not os.path.exists(JOB_PATH):
        job_list = [] 
        print('New job list!')
    else:
        job_list = pickle.load(open(JOB_PATH, 'rb'))
        checkProcess()
        print("Number of active jobs({})={}".format(len(job_list), job_list))

    if opts.summary or opts.plot or opts.best:
        global summary
        if not os.path.exists(SUMMARY_PATH):
            print("New app summary at {}".format(SUMMARY_PATH))
            summary = OrderedDict()
        else:
            summary = pickle.load(open(SUMMARY_PATH, 'rb'))
        for app in apps:
            if app not in summary:
                summary[app] = OrderedDict()

    if opts.clearAll:
        clearAll()
    elif opts.regression:
        regression()
    else:
        expRun()

    if opts.summary:
        pickle.dump(summary, open(SUMMARY_PATH, 'wb'))
        summaryToCsv()

    if opts.best:
        bestSummary()

    if opts.plot:
        plot()
    #################################################################################################################

if __name__ == "__main__":
    main()

