#!/usr/bin/env python

from os import listdir
from os.path import isfile, isdir, join, splitext, basename, dirname 
from collections import OrderedDict
import os
import argparse
import subprocess
import commands
import time
import pickle
import signal
import psutil
import shutil
import numpy as np
import types
import csv

lanes = 16
bankSize = 32 * 1024 / 4
proc_thresh = 40

SPATIAL_HOME = os.environ['SPATIAL_HOME']
PIR_HOME = os.environ['PIR_HOME']
APP_DIR='{}/apps/src/'.format(SPATIAL_HOME)
JOB_PATH="{}/gen/job_list.pickle".format(SPATIAL_HOME)
SUMMARY_PATH="{}/apps/summary.pickle".format(SPATIAL_HOME)
SUMMARY_CSV_PATH="{}/apps/summary.csv".format(SPATIAL_HOME)
apps = ['DotProduct', 'TPCHQ6', 'GDA', 'BlackScholes', 'Kmeans_plasticine', 'PageRank_plasticine', 'SPMV_CRS', 'GEMM_Blocked']
passes=["GEN_PIR","FIT_PIR","GEN_CHISEL","MAKE_VCS","MAP_PIR","RUN_SIMULATION"]
progress_cache = {}
cycle_cache = {}
summary_headers = ['App', 'cycle', 'pcuUtil', 'mcuUtil', 'scuUtil', 'ocuUtil', 'mcUtil', 'ocuUtil', 'mcUtil',
    'slinkUtil', 'vlinkUtil', 'clinkUtil', 'totalRegUtil', 'totalFUUtil', 'totalSBufUtil', 
    'totalVBufUtil']

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def sargs(args):
    return '_'.join([str(a) for a in args])

def getFullName(app, args, params):
    postfix = sargs(args) 
    postfix = postfix + ''.join(["_{}_{}".format(k,str(params[k])) for k in params ]) 
    fullname = '{}_{}'.format(app, postfix)
    fullname = fullname.replace('.','d')
    return fullname

def copyApp(app, args, params):
    path = '{0}/{1}.scala'.format(APP_DIR, app)
    fullname = getFullName(app, args, params) 
    if not os.path.exists('{}/gen'.format(APP_DIR)):
        os.makedirs('{}/gen'.format(APP_DIR))
    newpath = '{0}/gen/{1}.scala'.format(APP_DIR, fullname)
    paramFound = {}
    with open(newpath, 'w') as newapp:
        with open(path, 'r') as origapp :
            for line in origapp:
                found = False
                if 'object {}'.format(app) in line:
                    newapp.write(line.replace(app, fullname))
                    found = True
                for param in params:
                    if 'val {} = '.format(param) in line:
                        newapp.write('val {} = {}\n'.format(param, params[param]))
                        paramFound[param] = True
                        found = True
                if not found:
                    newapp.write(line)
    for param in params:
        if param not in paramFound:
            print('Param {} not found !!!'.format(param))
            exit()

def checkProcess():
    for pid in job_list:
        if not os.path.exists("/proc/{}".format(pid)):
            job_list.remove(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))

def waitProcess():
    checkProcess()
    if len(job_list) > proc_thresh:
        time.sleep(5)
        waitProcess()

def runApp(app, args, params):
    if opts.parallel:
        waitProcess()
        signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    copyApp(app, args, params)
    fullname = getFullName(app, args, params)
    command = "apps/bin/runapp {} {} {} {}".format(fullname, ' '.join([str(a) for a in args]),
            opts.torun, opts.regen)
    print('command={}'.format(command))
    proc = subprocess.Popen(command.split(), shell=False)
    pid = proc.pid
    job_list.append(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))
    if opts.parallel:
        time.sleep(1)
    else:
        proc.wait()

def clear(app, args, params):
    fullname = getFullName(app, args, params)
    command = "rm -r gen/{}/Top.vcd".format(fullname)
    print(command)
    subprocess.call(command, shell=True)

def clearAll():
    dirs = [join('gen', d) for d in listdir('gen') if isdir(join('gen', d))]
    for d in dirs:
        files = [join(d, f) for f in listdir(d) if f != 'sim.log']
        for f in files:
            print('removing {}'.format(f))
            if isdir(f):
                shutil.rmtree(f)
            elif isfile(f):
                os.remove(f)
            
count = 0
def status(app, args, params):
    global count
    fullname = getFullName(app, args, params)
    command = "apps/bin/status {}".format(fullname)
    print(command)
    proc = subprocess.Popen(command, shell=True)
    proc.wait()
    # raw_input("status[{}]: Press Enter to continue...\n".format(count))
    count += 1
    # proc.kill()

def logs(app, passName):
    if passName=="GEN_PIR":
        return '{}/gen/{}/gen_pir.log'.format(SPATIAL_HOME, app)
    elif passName=="FIT_PIR":
        return '{}/out/{}/fit_pir.log'.format(PIR_HOME,app)
    elif passName=="GEN_CHISEL":
        return '{}/gen/{}/gen_chisel.log'.format(SPATIAL_HOME,app)
    elif passName=="MAKE_VCS":
        return '{}/gen/{}/vcs.log'.format(SPATIAL_HOME,app)
    elif passName=="MAP_PIR":
        return '{}/out/{}/map_pir.log'.format(PIR_HOME,app)
    elif passName=="RUN_SIMULATION":
        return '{}/gen/{}/sim.log'.format(SPATIAL_HOME, app)
    elif passName=="Utilization":
        return '{}/out/{}/ResourceAnalysis.log'.format(PIR_HOME, app)

def grep(path, patterns):
    found = None
    if type(patterns)!=list:
        patterns = [patterns]
    with open(path, 'r') as f:
        for line in f:
            for pattern in patterns:
                if pattern in line:
                    found = line
                    break
    return found

def cycleOf(app):
    if app in cycle_cache:
        return cycle_cache[app]
    log = logs(app, "RUN_SIMULATION")
    line = grep(log, ["Design ran for"])
    if line is None:
        return None
    else:
        cycle = int(line.split("Design ran for ")[1].split(" ")[0])
        cycle_cache[app] = cycle
        return cycle

def progress(app, passName):
    if (app, passName) in progress_cache:
        return progress_cache[(app, passName)]
    log = logs(app, passName)
    prog = "NONE"
    if os.path.exists(log):
        isDone=(grep(log,"{}(DONE)".format(passName)) is not None)
        if isDone:
	    isFailed=grep(log, ['error','Error','ERROR','No rule to make', 'Killed', 'KILLED']) is not None
            if passName=="RUN_SIMULATION":
	        hasCycle=cycleOf(app) is not None
	        timeOut=grep(log, 'Hardware timeout after') is not None
                if not hasCycle or timeOut:
                    isFailed = True
            if isFailed: 
	        prog = "FAILED"
            else:
	        prog = "SUCCESS"
        else:
	    prog = "RUNNING"
    else:
        prog = "NOTRUN"
    progress_cache[(app,passName)] = prog
    return prog

def success(app, passName):
    return progress(app, passName)=="SUCCESS"

def getUtil(line):
    used,total=line.split("Util(")[1].split(')')[0].split(',')
    used = int(used)
    total = int(total)
    return (used, total)

def summarize(app, args, params):
    global summary
    fullname = getFullName(app, args, params)
    # for p in passes:
        # print(p, progress(fullname,p))
    if success(fullname, "MAP_PIR") and success(fullname, "RUN_SIMULATION"):
        if fullname not in summary[app][sargs(args)]:
            summary[app][sargs(args)][fullname] = OrderedDict()
            table = summary[app][sargs(args)][fullname]
            cycle = cycleOf(fullname) 
            table['cycle'] = cycle
            reslog = logs(fullname, "Utilization")
            with open(reslog, 'rb') as f:
                for line in f:
                    for header in summary_headers:
                        if header in line:
                            table[header] = getUtil(line)

def summaryToCsv():
    global summary
    with open(SUMMARY_CSV_PATH, 'w') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=summary_headers)
        writer.writeheader()
        for app in summary:
            for arg in summary[app]:
                for fullname in summary[app][arg]: 
                    dict = {'App':fullname}
                    for header in summary[app][arg][fullname]:
                        if header not in ['App', 'cycle']:
                            used, total = summary[app][arg][fullname][header]
                            dict[header] = round(float(used) / float(total), 3)
                        else:
                            dict[header] = summary[app][arg][fullname][header]
                    writer.writerow(dict)


def target(app, args, params):
    if opts.run:
        runApp(app, args, params)
    elif opts.status:
        status(app, args, params)
    elif opts.summary:
        summarize(app, args, params)

def dse(app, args, params):
    # print(params)
    for param in params:
        # print('  param:' + param + ' = ' + str(params[param]))
        if type(params[param]) is list:
            if len(params[param])==0:
                return 0
            newParams = params.copy()
            cnt = 0
            if opts.single:
                params[param] = [params[param][0]]
            for val in params[param]:
                newParams[param] = val
                cnt += dse(app, args, newParams)
            return cnt
        elif type(params[param]) is types.LambdaType:
            newParams = params.copy()
            newParams[param] = params[param](params)
            return dse(app, args, newParams)
        else:
            continue
    print('{}{} args={} and params=[{}]{}'.format(bcolors.UNDERLINE, app, str(args),
        ' '.join(['{}={}'.format(p,params[p]) for p in params]), bcolors.ENDC))
    target(app, args, params)
    return 1

def irange(start, stop, step):
    r = range(start, stop, step)
    if (len(r)>0):
        last = r[-1]
    else:
        last = start
    if(last+step==stop):
        r.append(stop)
    return r

def addArgs(app, args):
    if opts.summary:
        if sargs(args) not in summary[app]: 
            summary[app][sargs(args)] = OrderedDict()

# tucson
def TPCHQ6():
    app = 'TPCHQ6'
    space = 0
    N = 96000
    args = [N]
    addArgs(app, args)

    # FINISHED
    params = OrderedDict()
    params['outerPar'] = irange(1, 10, 2) 
    params['tileSize'] = lambda params: irange(3000, min(bankSize, N/params['outerPar']/4), 3000)
    space += dse(app, args, params)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(6, 10, 2) 
    params['tileSize'] = lambda params: irange(400, min(bankSize, N/params['outerPar']/4), 800)
    space += dse(app, args, params)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(2, 10, 2) 
    params['tileSize'] = lambda params: irange(16, min(bankSize, N/params['outerPar']/200), 16*2)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# tucson
def GDA():
    app = 'GDA'
    space = 0

    # R = 192000
    # MAXC = 80
    # args = [R]
    # addArgs(app, args)

    # # Finished 
    # params = OrderedDict()
    # # params['tileSize'] = irange(16, 16*5, 16) 
    # params['tileSize'] = irange(16, bankSize*lanes/MAXC, 512) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 
    # space += dse(app, args, params)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(16, 16*3, 16*2) 
    # params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    # params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 
    # space += dse(app, args, params)

    # portland
    R = 19200
    MAXC = 80
    args = [R]
    addArgs(app, args)

    # Finished 
    params = OrderedDict()
    params['tileSize'] = irange(1024, bankSize*lanes/MAXC, 1024) 
    params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 
    space += dse(app, args, params)

    # Finished 
    params = OrderedDict()
    params['tileSize'] = irange(1024, bankSize*lanes/MAXC, 1024) 
    params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# london
def GEMM_Blocked():
    app = 'GEMM_Blocked'
    space = 0
    dim = 512
    # args += [dim]
    args = []
    addArgs(app, args)

    params = OrderedDict()
    params['tileSize']   = [16, 256] # irange(16, dim, 16)
    params['i_tileSize'] = [16, 256] # irange(16, dim, 16)
    params['loop_jj']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_ii']    = lambda params: irange(1 , min(dim/params['i_tileSize'], 2), 1)
    params['loop_kk']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_i']     = lambda params: irange(1 , min(params['i_tileSize']    , 2), 1)
    params['loop_k']     = lambda params: irange(1 , min(params['tileSize']      , 2), 1)
    space += dse(app, args, params)

    params = OrderedDict()
    params['tileSize']   = [256] # irange(16, dim, 16)
    params['i_tileSize'] = [256] # irange(16, dim, 16)
    params['loop_jj']    = 1 
    params['loop_ii']    = 1
    params['loop_kk']    = 1
    params['loop_i']     = [1,2,3,4,5]
    params['loop_k']     = [1,2,3,4,5]
    space += dse(app, args, params)
    print('{} space: {}'.format(app, space))

# london
def BlackScholes():
    app = 'BlackScholes'
    space = 0
    N = 1966080  
    args = [N]
    addArgs(app, args)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(1, 4, 1) 
    params['tileSize'] = lambda params: irange(1024, min(bankSize, N/params['outerPar']), 1024)
    space += dse(app, args, params)

    params = OrderedDict()
    params['outerPar'] = 1 
    params['tileSize'] = lambda params: irange(1024*16, min(bankSize*lanes,N/params['outerPar']),1024*16)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

def PageRank_plasticine():
    app = 'PageRank_plasticine'
    space = 0
    iters = 1
    NP = 491520 # 2048 in simulation
    damp = 0.125
    args = [iters, NP, damp]
    addArgs(app, args)

    params = OrderedDict()
    maxTile = min(bankSize*lanes,NP)
    params['tileSize'] = [16, 1024, 1024*6, maxTile/4, maxTile/2, maxTile] 
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# london
def Kmeans_plasticine():
    app = 'Kmeans_plasticine'
    space = 0
    iter = 1
    N = 6144
    dim = 96
    args = [1, N]
    addArgs(app, args)

    # Finished 
    params = OrderedDict()
    params['tileSize'] = irange(16, 16, 1) + irange(128, 512, 128) + irange(1024,min(bankSize*lanes/dim, N), 1024)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# tucson
def SPMV_CRS():
    app = 'SPMV_CRS'
    space = 0
    N = 494
    args = []
    addArgs(app, args)

    params = OrderedDict()
    maxTile = min(bankSize*lanes, N)
    # Finished
    params['tileSize'] = irange(16, maxTile, 64) 
    params['tile_par'] = lambda params: irange(1, min(5, N/params['tileSize']), 2) + [2]
    params['pt_par'] = lambda params: irange(1, min(5, params['tileSize']), 2) + [2]
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

def expRun():
    #################################################################################################################
    ###                                                ASPLOS 2018                                           ########
    #################################################################################################################

    ### TO RUN        ######################################################################################################
    app = opts.app

    if app in ['TPCHQ6', 'ALL']:
        TPCHQ6()
    if app in ['GDA', 'ALL']:
        GDA()
    if app in ['GEMM_Blocked', 'ALL']:
        GEMM_Blocked()
    if app in ['BlackScholes', 'ALL']:
        BlackScholes()
    if app in ['Kmeans_plasticine', 'ALL']:
        Kmeans_plasticine()
    if app in ['PageRank_plasticine', 'ALL']:
        PageRank_plasticine()
    if app in ['SPMV_CRS', 'ALL']:
        SPMV_CRS()

def main():
    parser = argparse.ArgumentParser(description='Run experiments')
    parser.add_argument('--parallel', dest='parallel', action='store_true', default=False) 
    parser.add_argument('--single', dest='single', action='store_true', default=False) 
    parser.add_argument('--run', dest='run', action='store_true', default=False) 
    parser.add_argument('--status', dest='status', action='store_true', default=False) 
    parser.add_argument('--clearAll', dest='clearAll', action='store_true', default=False) 
    parser.add_argument('--app', dest='app', action='store', default='DotProduct',help='App name')
    parser.add_argument('--regen', dest='regen', action='store', default='false',
        help='force pass to rerun' )
    parser.add_argument('--torun', dest='torun', action='store', default='ALL',
        help='Pass to run')
    parser.add_argument('--summary', dest='summary', action='store_true', default=False) 

    global opts
    (opts, args) = parser.parse_known_args()

    os.chdir(SPATIAL_HOME)
    if not os.path.exists('{}/gen'.format(SPATIAL_HOME)):
        os.makedirs('{}/gen'.format(SPATIAL_HOME))
    global job_list
    if not os.path.exists(JOB_PATH):
        job_list = [] 
        print('New job list!')
    else:
        job_list = pickle.load(open(JOB_PATH, 'rb'))
        checkProcess()
        print("Number of active jobs({})={}".format(len(job_list), job_list))

    if opts.summary:
        global summary
        if not os.path.exists(SUMMARY_PATH):
            print("New app summary at {}".format(SUMMARY_PATH))
            summary = OrderedDict()
        else:
            summary = pickle.load(open(SUMMARY_PATH, 'rb'))
        for app in apps:
            if app not in summary:
                summary[app] = OrderedDict()

    if opts.clearAll:
        clearAll()
    else:
        expRun()

    if opts.summary:
        pickle.dump(summary, open(SUMMARY_PATH, 'wb'))
        summaryToCsv()
    #################################################################################################################

if __name__ == "__main__":
    main()

