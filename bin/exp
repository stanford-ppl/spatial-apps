#!/usr/bin/env python

from os import listdir
from os.path import isfile, isdir, join, splitext, basename, dirname 
from collections import OrderedDict
import os
import argparse
import subprocess
import commands
import time
import pickle
import signal
import psutil
import shutil
import numpy as np
import types

lanes = 16
bankSize = 32 * 1024 / 4
proc_thresh = 5

SPATIAL_HOME = os.environ['SPATIAL_HOME']
PIRL_HOME = os.environ['PIR_HOME']
APP_DIR='{}/apps/src/'.format(SPATIAL_HOME)
JOB_PATH="{}/gen/job_list.pickle".format(SPATIAL_HOME)

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def newAppName(app, args, params):
    postfix = '_'.join([str(a) for a in args])
    postfix = postfix + ''.join(["_{}_{}".format(k,str(params[k])) for k in params ]) 
    newname = '{}_{}'.format(app, postfix)
    newname = newname.replace('.','d')
    return newname

def copyApp(app, args, params):
    path = '{0}/{1}.scala'.format(APP_DIR, app)
    newname = newAppName(app, args, params) 
    if not os.path.exists('{}/gen'.format(APP_DIR)):
        os.makedirs(directory)
    newpath = '{0}/gen/{1}.scala'.format(APP_DIR, newname)
    paramFound = {}
    with open(newpath, 'w') as newapp:
        with open(path, 'r') as origapp :
            for line in origapp:
                found = False
                if 'object {}'.format(app) in line:
                    newapp.write(line.replace(app, newname))
                    found = True
                for param in params:
                    if 'val {} = '.format(param) in line:
                        newapp.write('val {} = {}\n'.format(param, params[param]))
                        paramFound[param] = True
                        found = True
                if not found:
                    newapp.write(line)
    for param in params:
        if param not in paramFound and param!='fpga':
            print('Param {} not found|||!'.format(param))
            exit()

def checkProcess():
    for pid in job_list:
        if not os.path.exists("/proc/{}".format(pid)):
            job_list.remove(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))

def waitProcess():
    checkProcess()
    if len(job_list) > proc_thresh:
        time.sleep(5)
        waitProcess()

def runApp(app, args, params, regen):
    waitProcess()
    copyApp(app, args, params)
    newname = newAppName(app, args, params)
    command = "apps/bin/runapp {} {} {}".format(newname, ' '.join([str(a) for a in args]), regen)
    print('command={}'.format(command))
    # signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    proc = subprocess.Popen(command.split(), shell=False)
    pid = proc.pid
    job_list.append(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))
    proc.wait()
    # time.sleep(1)

def clear(app, args, params, regen):
    newname = newAppName(app, args, params)
    command = "rm -r gen/{}/Top.vcd".format(newname)
    print(command)
    subprocess.call(command, shell=True)

def clearAll():
    dirs = [join('gen', d) for d in listdir('gen') if isdir(join('gen', d))]
    for d in dirs:
        files = [join(d, f) for f in listdir(d) if f != 'sim.log']
        for f in files:
            print('removing {}'.format(f))
            if isdir(f):
                shutil.rmtree(f)
            elif isfile(f):
                os.remove(f)
            
count = 0
def status(app, args, params, regen):
    global count
    newname = newAppName(app, args, params)
    command = "apps/bin/status {}".format(newname)
    print(command)
    proc = subprocess.Popen(command, shell=True)
    proc.wait()
    # raw_input("status[{}]: Press Enter to continue...\n".format(count))
    count += 1
    # proc.kill()

def target(app, args, params, regen):
    if opts.run:
        runApp(app, args, params, regen)
    elif opts.status:
        status(app, args, params, regen)

def dse(app, args, params, regen):
    # print(params)
    for param in params:
        # print('  param:' + param + ' = ' + str(params[param]))
        if type(params[param]) is list:
            if len(params[param])==0:
                return
            newParams = params.copy()
            cnt = 0
            if opts.single:
                params[param] = [params[param][0]]
            for val in params[param]:
                newParams[param] = val
                cnt += dse(app, args, newParams, regen)
            return cnt
        elif type(params[param]) is types.LambdaType:
            newParams = params.copy()
            newParams[param] = params[param](params)
            return dse(app, args, newParams, regen)
        else:
            continue
    print('{}{} args={} and params=[{}]{}'.format(bcolors.UNDERLINE, app, str(args),
        ' '.join(['{}={}'.format(p,params[p]) for p in params]), bcolors.ENDC))
    target(app, args, params, regen)
    return 1

def irange(start, stop, step):
    return range(start, stop+step, step)

def expRun():
    #################################################################################################################
    ###                                                ASPLOS 2018                                           ########
    #################################################################################################################

    ### TO RUN        ######################################################################################################
    params = OrderedDict()

    regen = 'false'
    app = 'TPCHQ6'
    N = 96000
    args = [N]

    # FINISHED
    # params['outerPar'] = irange(1, 10, 2) 
    # params['tileSize'] = lambda params: irange(3000, min(bankSize, N/params['outerPar']/4), 3000)

    # TODO run one more time
    # params['outerPar'] = irange(6, 10, 2) 
    # params['tileSize'] = lambda params: irange(400, min(bankSize, N/params['outerPar']/4), 800)

    # TODO run one more time
    # params['outerPar'] = irange(2, 10, 2) 
    # params['tileSize'] = lambda params: irange(16, min(bankSize, N/params['outerPar']/200), 16*2)

    regen = 'false'
    app = 'GDA'
    R = 192000
    args = [R]

    # TODO 
    # params['tileSize'] = irange(16, 16, 16) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 

    # TODO 
    # params['tileSize'] = irange(16*5, 16*5, 16) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 

    # TODO 
    # params['tileSize'] = irange(16*3, 16*3, 16) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 

    regen = 'false'
    app = 'GEMM_Blocked'
    args = []
    dim = 64

    params['tileSize'] = irange(16, dim, 16) 
    params['loop_jj'] = lambda params: irange(1, dim/params['tileSize'], 1) 
    params['loop_kk'] = lambda params: irange(1, dim/params['tileSize'], 1) 
    params['loop_ii'] = irange(1, min(dim, 5), 2) 
    params['loop_k']  = lambda params: irange(1, min(params['tileSize'], 5), 2)

    space = dse(app, args, params, regen)
    print('{} space: {}'.format(app, space))
    pass

def main():
    parser = argparse.ArgumentParser(description='Run experiments')
    parser.add_argument('--single', dest='single', action='store_true', default=False) 
    parser.add_argument('--run', dest='run', action='store_true', default=False) 
    parser.add_argument('--status', dest='status', action='store_true', default=False) 
    parser.add_argument('--clearAll', dest='clearAll', action='store_true', default=False) 
    global opts
    (opts, args) = parser.parse_known_args()

    os.chdir(SPATIAL_HOME)
    global job_list
    if not os.path.exists(JOB_PATH):
        job_list = [] 
        print('New job list!')
    else:
        job_list = pickle.load(open(JOB_PATH, 'rb'))
        checkProcess()
        print("Number of active jobs({})={}".format(len(job_list), job_list))

    if opts.clearAll:
        clearAll()
    else:
        expRun()

    #################################################################################################################

if __name__ == "__main__":
    main()

