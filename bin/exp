#!/usr/bin/env python

from os import listdir
from os.path import isfile, isdir, join, splitext, basename, dirname 
from collections import OrderedDict
import os
import argparse
import subprocess
import commands
import time
import pickle
import signal
import psutil
import shutil
import numpy as np
import types
import csv

import matplotlib
import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import matplotlib.ticker as ticker
import os, sys
import math

lanes = 16
bankSize = 32 * 1024 / 4
proc_thresh = 40
max_bw = 12.8*4

HOME = os.environ['HOME']
SPATIAL_HOME = os.environ['SPATIAL_HOME']
PIR_HOME = os.environ['PIR_HOME']
APP_DIR='{}/apps/src/'.format(SPATIAL_HOME)
JOB_PATH="{}/gen/job_list.pickle".format(SPATIAL_HOME)
SUMMARY_PATH="{}/apps/summary.pickle".format(SPATIAL_HOME)
SUMMARY_CSV_PATH="{}/apps/summary.csv".format(SPATIAL_HOME)
BEST_SUMMARY_CSV_PATH="{}/apps/best.csv".format(SPATIAL_HOME)
apps = ['DotProduct', 'TPCHQ6', 'GDA', 'BlackScholes', 'Kmeans_plasticine', 'PageRank_plasticine', 'SPMV_CRS', 'GEMM_Blocked']
passes=["GEN_PIR","FIT_PIR","GEN_CHISEL","MAKE_VCS","MAP_PIR","RUN_SIMULATION"]
progress_cache = {}
cycle_cache = {}
summary_headers = ['App', 'cycle', 'lavgbw', 'savgbw', 'pcuUtil', 'mcuUtil', 'scuUtil', 'ocuUtil', 'mcUtil', 'ocuUtil', 'mcUtil',
    'slinkUtil', 'vlinkUtil', 'clinkUtil', 'totalRegUtil', 'totalFUUtil', 'totalSBufUtil', 
    'totalVBufUtil']

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def plot_zynq():
    zynq_apps = ['Sobel', 'GEMM', 'GDA', 'SW', 'AES','TPC-H Q6', 'K-Means', 'PageRank']

    apps = zynq_apps
    zynq_time = {}
    zynq_time['Sobel'] = 167.84638 * (1024/320)
    zynq_time['GEMM'] = 14362.10847 * (8) # 1024
    zynq_time['GDA'] = 96.3459 # 1024 
    zynq_time['SW'] = 0.19313 * ((512 / 160) ** 2 )# 160
    zynq_time['AES'] = 72.671889 * (1000 / 200) # 200
    zynq_time['TPC-H Q6'] = 279.428227
    zynq_time['K-Means'] = 377.602213 * (4) # 100 320  ??
    zynq_time['PageRank'] = 2166.915

    f1_time = {}
    f1_time['Sobel'] = 245.9696
    f1_time['GEMM'] = 5024.76 # 2048
    f1_time['GDA'] = 38.0967 # 1024 
    f1_time['SW'] = 5.08672 # 512 
    f1_time['AES'] = 74.6296 # 1000
    f1_time['TPC-H Q6'] = 180.084 
    f1_time['K-Means'] = 615.012 # (200 640)  ??
    f1_time['PageRank'] = 1462.61 # (10000 0.5)

    speedups = []
    for app in apps:
        speedups.append( zynq_time[app] / f1_time[app] )

    ind = np.arange(len(apps))+0.1  # the x locations for the groups
    # slices  = (np.arange(len(apps))+1) * 1.0 / len(apps)
    # bram    = (np.arange(len(apps))+1) * 1.0 / len(apps)
    # dsp     = (np.arange(len(apps))+1) * 1.0 / len(apps)

    width = 0.6       # the width of the bars

    fig, ax = plt.subplots()
    bar1 = ax.bar(ind, speedups, width, color='royalblue')
    # bar2 = ax.bar(ind + width, slices, width, color='gold')
    # bar3 = ax.bar(ind + 2*width, bram, width, color='olivedrab')
    # bar4 = ax.bar(ind + 3*width, dsp, width, color='dodgerblue')

    # add some text for labels, title and axes ticks
    ax.set_ylabel('Speedup')
    # ax.set_ylim(0, 1)
    ax.set_xlim(0, len(apps))
    # ax.set_title('Scores by group and gender')
    ax.set_xticks(ind + 0.2*width)
    ax.set_xticklabels(apps, rotation=30)

    plt.grid(True)
    plot_path = '{}/papers/spatial/figs/zynq_comp.png'.format(HOME)
    fig.set_size_inches(6,2.5)
    plt.gcf().subplots_adjust(bottom=0.3)
    plt.savefig(plot_path, format='png', dpi=900)

def plot_f1():
    f1_apps = ['AES', 'BlackScholes', 'GEMM', 'K-Means',
            'SW', 'PageRank', 'TPC-H Q6']
    # f1_apps = ['AES', 'BlackScholes', 'GEMM', 'K-Means', 'Sobel', 
            # 'SW', 'PageRank', 'TPC-H Q6']

    apps = f1_apps
    ind = np.arange(len(apps))+0.1  # the x locations for the groups

    f1_time = {}
    f1_time['Sobel'] = 245.9696
    f1_time['BlackScholes'] = 5.47018 # 153600
    f1_time['GEMM'] = 5024.76 # 2048
    f1_time['GDA'] = 38.0967 # 1024 
    f1_time['SW'] = 5.08672 # 512 
    f1_time['AES'] = 74.6296 # 1000
    f1_time['TPC-H Q6'] = 180.084 
    f1_time['K-Means'] = 615.012 # (200 640)  ??
    f1_time['PageRank'] = 1462.61 # (10000 0.5)

    sd_time = {}
    sd_time['Sobel'] = 0.33873
    sd_time['BlackScholes'] = 4.5
    sd_time['GEMM'] = 6315.4
    sd_time['GDA'] = 1
    sd_time['SW'] = 7.036 # 256
    sd_time['AES'] =  1.243659
    sd_time['TPC-H Q6'] =  13675.7
    sd_time['K-Means'] = 985.91
    sd_time['PageRank'] = 2041.7

    f1_slice= {}
    f1_bram = {}
    f1_dsp = {}
    f1_slice['BlackScholes'] = 550755
    f1_bram['BlackScholes']  = 64
    f1_dsp['BlackScholes']   = 985

    f1_slice['Sobel']        = 285926
    f1_bram['Sobel']         = 241
    f1_dsp['Sobel']          = 1494

    f1_slice['GEMM']         = 94334
    f1_bram['GEMM']          = 43 
    f1_dsp['GEMM']           = 411 

    f1_slice['GDA']          = 80932
    f1_bram['GDA']           = 246.5
    f1_dsp['GDA']            = 171 

    f1_slice['SW']           = 69087
    f1_bram['SW']            = 925
    f1_dsp['SW']             = 423

    f1_slice['AES']          = 243918
    f1_bram['AES']           = 62
    f1_dsp['AES']            = 461

    f1_slice['TPC-H Q6']     = 138954
    f1_bram['TPC-H Q6']      = 68
    f1_dsp['TPC-H Q6']       = 162

    f1_slice['K-Means']      = 59997
    f1_bram['K-Means']       = 25
    f1_dsp['K-Means']        = 102

    f1_slice['PageRank']     = 50683
    f1_bram['PageRank']      = 64
    f1_dsp['PageRank']       = 207

    sd_slice= {}
    sd_bram = {}
    sd_dsp = {}
    sd_slice['BlackScholes'] = 353073
    sd_bram['BlackScholes']  = 550
    sd_dsp['BlackScholes']   = 290

    sd_slice['Sobel']        = 1
    sd_bram['Sobel']         = 1
    sd_dsp['Sobel']          = 1

    sd_slice['GEMM']         = 94334
    sd_bram['GEMM']          = 43 
    sd_dsp['GEMM']           = 411 

    sd_slice['GDA']          = 80932
    sd_bram['GDA']           = 246.5
    sd_dsp['GDA']            = 171 

    sd_slice['SW']           = 69087
    sd_bram['SW']            = 925
    sd_dsp['SW']             = 423

    sd_slice['AES']          = 339179
    sd_bram['AES']           = 589
    sd_dsp['AES']            = 12

    sd_slice['TPC-H Q6']     = 336679
    sd_bram['TPC-H Q6']      = 578
    sd_dsp['TPC-H Q6']       = 18

    sd_slice['K-Means']      = 356475
    sd_bram['K-Means']       = 657
    sd_dsp['K-Means']        = 539

    sd_slice['PageRank']     = 337250 
    sd_bram['PageRank']      = 549
    sd_dsp['PageRank']       = 17

    speedup = [1.0*sd_time[app] / f1_time[app] for app in apps]
    slices = [1.0*sd_slice[app] / f1_slice[app] for app in apps]
    bram = [1.0*sd_bram[app] /f1_bram[app]  for app in apps]
    dsp = [1.0*sd_dsp[app] / f1_dsp[app] for app in apps]

    width = 0.2       # the width of the bars

    fig, ax = plt.subplots()
    bar1 = ax.bar(ind, speedup, width, color='orangered')
    bar2 = ax.bar(ind + width, slices, width, color='gold')
    bar3 = ax.bar(ind + 2*width, bram, width, color='olivedrab')
    bar4 = ax.bar(ind + 3*width, dsp, width, color='dodgerblue')

    # add some text for labels, title and axes ticks
    ax.set_ylabel('Improvement')
    ax.set_yscale('log')
    # ax.set_ylim(0, 1)
    ax.set_xlim(0, len(apps))
    # ax.set_title('Scores by group and gender')
    ax.set_xticks(ind + width)
    ax.set_xticklabels(apps, rotation=30)
    ax.legend((bar1[0], bar2[0], bar3[0], bar4[0]), ('Speedup', 'Slice', 'BRAM', 'DSP'), ncol=4,
            fontsize=10)

    plt.grid(True)
    plot_path = '{}/papers/spatial/figs/f1_comp.png'.format(HOME)
    fig.set_size_inches(8,3)
    plt.gcf().subplots_adjust(bottom=0.3)
    plt.savefig(plot_path, format='png', dpi=900)

def plot():
    cmap = matplotlib.cm.get_cmap('Oranges')
    for app in apps:
        if app==opts.app or opts.app=='ALL':
            for args in summary[app]:
                fig, ax = plt.subplots()
                for fullname in summary[app][args]:
                    tileSize = int(fullname.split('tileSize_')[1].split('_')[0])
                    used, total = summary[app][args][fullname]['pcuUtil']
                    pcu = futil(used, total)
                    used, total = summary[app][args][fullname]['mcuUtil']
                    mcu = futil(used, total)
                    used, total = summary[app][args][fullname]['mcUtil']
                    mc = futil(used, total)
                    lavgbw = summary[app][args][fullname]['lavgbw']
                    cycle = summary[app][args][fullname]['cycle']
                    # sp = ax.scatter(pcu, cycle, c = color_spd, s = dotSize, marker = marker_pd, edgecolors='none')
                    size = mcu * 200
                    # size = mc * 100
                    # size = mc * 100
                    # size = lavgbw
                    # size = tileSize 
                    bw = (lavgbw + 3) / 15
                    color = cmap(bw)
                    # color = cmap(max_bw - lavgbw/max_bw)
                    cycle = float(cycle) / (7.5 * (10 ** 7))
                    if tileSize==16:
                        ec = 'none'
                    else:
                        ec = 'k'
                    sp = ax.scatter(pcu * 100, cycle, c=color, s=size, edgecolors=ec)
                plot_path = '{}/apps/{}_{}.png'.format(SPATIAL_HOME,app, args)
                plt.grid(True)
                plt.xlabel('PCU Utilization (%)')
                plt.ylabel('Runtime')
                ax.set_ylim(0,1)
                fig.set_size_inches(6,4)
                plt.gcf().subplots_adjust(bottom=0.15)
                plt.savefig(plot_path, format='png', dpi=900)
                print('Generate {}'.format(plot_path))

def sargs(args):
    return '_'.join([str(a) for a in args])

def getFullName(app, args, params):
    postfix = sargs(args) 
    postfix = postfix + ''.join(["_{}_{}".format(k,str(params[k])) for k in params ]) 
    fullname = '{}_{}'.format(app, postfix)
    fullname = fullname.replace('.','d')
    return fullname

def copyApp(app, args, params):
    path = '{0}/{1}.scala'.format(APP_DIR, app)
    fullname = getFullName(app, args, params) 
    if not os.path.exists('{}/gen'.format(APP_DIR)):
        os.makedirs('{}/gen'.format(APP_DIR))
    newpath = '{0}/gen/{1}.scala'.format(APP_DIR, fullname)
    paramFound = {}
    with open(newpath, 'w') as newapp:
        with open(path, 'r') as origapp :
            for line in origapp:
                found = False
                if 'object {}'.format(app) in line:
                    newapp.write(line.replace(app, fullname))
                    found = True
                for param in params:
                    if 'val {} = '.format(param) in line:
                        newapp.write('val {} = {}\n'.format(param, params[param]))
                        paramFound[param] = True
                        found = True
                if not found:
                    newapp.write(line)
    for param in params:
        if param not in paramFound:
            print('Param {} not found !!!'.format(param))
            exit()

def checkProcess():
    for pid in job_list:
        if not os.path.exists("/proc/{}".format(pid)):
            job_list.remove(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))

def waitProcess():
    checkProcess()
    if len(job_list) > proc_thresh:
        time.sleep(5)
        waitProcess()

def runApp(app, args, params):
    if opts.parallel:
        waitProcess()
        signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    copyApp(app, args, params)
    fullname = getFullName(app, args, params)
    command = "apps/bin/runapp {} {} {} {}".format(fullname, ' '.join([str(a) for a in args]),
            opts.torun, opts.regen)
    print('command={}'.format(command))
    proc = subprocess.Popen(command.split(), shell=False)
    pid = proc.pid
    job_list.append(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))
    if opts.parallel:
        time.sleep(1)
    else:
        proc.wait()

def clear(app, args, params):
    fullname = getFullName(app, args, params)
    command = "rm -r gen/{}/Top.vcd".format(fullname)
    print(command)
    subprocess.call(command, shell=True)

def clearAll():
    dirs = [join('gen', d) for d in listdir('gen') if isdir(join('gen', d))]
    for d in dirs:
        files = [join(d, f) for f in listdir(d) if f != 'sim.log']
        for f in files:
            print('removing {}'.format(f))
            if isdir(f):
                shutil.rmtree(f)
            elif isfile(f):
                os.remove(f)
            
count = 0
def status(app, args, params):
    global count
    fullname = getFullName(app, args, params)
    command = "apps/bin/status {}".format(fullname)
    print(command)
    proc = subprocess.Popen(command, shell=True)
    proc.wait()
    # raw_input("status[{}]: Press Enter to continue...\n".format(count))
    count += 1
    # proc.kill()

def logs(app, passName):
    if passName=="GEN_PIR":
        return '{}/gen/{}/gen_pir.log'.format(SPATIAL_HOME, app)
    elif passName=="FIT_PIR":
        return '{}/out/{}/fit_pir.log'.format(PIR_HOME,app)
    elif passName=="GEN_CHISEL":
        return '{}/gen/{}/gen_chisel.log'.format(SPATIAL_HOME,app)
    elif passName=="MAKE_VCS":
        return '{}/gen/{}/vcs.log'.format(SPATIAL_HOME,app)
    elif passName=="MAP_PIR":
        return '{}/out/{}/map_pir.log'.format(PIR_HOME,app)
    elif passName=="RUN_SIMULATION":
        return '{}/gen/{}/sim.log'.format(SPATIAL_HOME, app)
    elif passName=="Utilization":
        return '{}/out/{}/ResourceAnalysis.log'.format(PIR_HOME, app)

def grep(path, patterns):
    found = None
    if type(patterns)!=list:
        patterns = [patterns]
    with open(path, 'r') as f:
        for line in f:
            for pattern in patterns:
                if pattern in line:
                    found = line
                    break
    return found

def cycleOf(app):
    if app in cycle_cache:
        return cycle_cache[app]
    log = logs(app, "RUN_SIMULATION")
    line = grep(log, ["Design ran for"])
    if line is None:
        return None
    else:
        cycle = int(line.split("Design ran for ")[1].split(" ")[0])
        cycle_cache[app] = cycle
        return cycle

def progress(app, passName):
    if (app, passName) in progress_cache:
        return progress_cache[(app, passName)]
    log = logs(app, passName)
    prog = "NONE"
    if os.path.exists(log):
        isDone=(grep(log,"{}(DONE)".format(passName)) is not None)
        if isDone:
	    isFailed=grep(log, ['error','Error','ERROR','No rule to make', 'Killed', 'KILLED']) is not None
            if passName=="RUN_SIMULATION":
	        hasCycle=cycleOf(app) is not None
	        timeOut=grep(log, 'Hardware timeout after') is not None
                if not hasCycle or timeOut:
                    isFailed = True
            if isFailed: 
	        prog = "FAILED"
            else:
	        prog = "SUCCESS"
        else:
	    prog = "RUNNING"
    else:
        prog = "NOTRUN"
    progress_cache[(app,passName)] = prog
    return prog

def success(app, passName):
    return progress(app, passName)=="SUCCESS"

def getUtil(line):
    used,total=line.split("Util(")[1].split(')')[0].split(',')
    used = int(used)
    total = int(total)
    return (used, total)

def avgbw(app, args, params):
    lword = 0
    sword = 0
    if 'TPCHQ6' in app:
        N, = args
        lword += N * 4 # load 4 data stucture
    elif 'GDA' in app:
        R = args[0]
        C = 96
        lword += C * 2 # load mu0, mu1
        lword += R # load y
        lword += R * C # load x
        sword += C * C # store sigma
    elif 'BlackScholes' in app:
        N = args[0]
        lword += N * 6 # load 6 data stucture
        sword += N # store optpriceBlk
    elif 'GEMM_Blocked' in app:
        dim = 512
        tileSize = params['tileSize']
        i_tileSize = params['i_tileSize']
        # load b_sram
        lword += (tileSize * tileSize) * (dim / tileSize) * (dim / tileSize) * (dim / i_tileSize)
        # load a_sram
        lword += (tileSize) * (i_tileSize) * (dim / tileSize) * (dim / tileSize) * (dim / i_tileSize)
        # store c_col
        sword += i_tileSize * tileSize * (dim / tileSize) * (dim / i_tileSize)
    elif 'Kmeans_plasticine' in app:
        iters = 1
        D = 96
        K = 20
        N = 6144
        dim = 96
        tileSize = params['tileSize']
        BN = tileSize
        BD = dim
        lword += K * D # load orgCts
        lword += (BN * BD) * (N / BN) * iters # pts
        sword += (K * D) # store centroids
    elif 'PageRank_plasticine' in app:
        # lword += tileSize * 3 * (NP / tileSize) * iters # load initPR, edgesId, edgesLen
        # lword += numEdges * 2 * tileSize * (NP / tileSize) * iters # load edges, counts
        # lword += num2gather * tileSize * (NP / tileSize) * iters # gather
        # sword += tileSize * (NP / tileSize)  * iters # store currentPR
        pass
    elif 'SPMV_CRS' in app:
        MAGIC = 15162342 
        # lword += (tileSize + 1) * (N / tileSize) # load rowid_sram 
        # lword += (stop_id - start_id) * tileSize * 
        simlog = logs(app, "RUN_SIMULATION")
        with open(simlog, 'rb') as f:
            for line in f:
                if "Sum of size (#bursts) of dense loads:" in line:
                    burst = int(line.split(":")[1].split("(")[1].split(")")[0])
                    lword += (burst-MAGIC) * 16
                if "Sum of size (#bursts) of dense stores:" in line:
                    burst = int(line.split(":")[1].split("(")[1].split(")")[0])
                    sword += (burst-MAGIC) * 16
                if "Sparse reads: " in line:
                    lword += int(line.split("(")[1].split(")")[0])  
                if "Sparse write: " in line:
                    sword += int(line.split("(")[1].split(")")[0])  
        pass

    lbyte = lword * 4
    sbyte = sword * 4
    second = float(cycleOf(app)) / (10 ** 9)
    lgbps = lbyte / second / (10 ** 9)
    sgbps = sbyte / second / (10 ** 9)
    return (lgbps, sgbps)

def summarize(app, args, params):
    global summary
    fullname = getFullName(app, args, params)
    # for p in passes:
        # print(p, progress(fullname,p))
    if success(fullname, "MAP_PIR") and success(fullname, "RUN_SIMULATION"):
        if fullname not in summary[app][sargs(args)]:
            print('summarize:{}'.format(fullname))
            summary[app][sargs(args)][fullname] = OrderedDict()
            table = summary[app][sargs(args)][fullname]
            cycle = cycleOf(fullname) 
            table['cycle'] = cycle
            table['lavgbw'], table['savgbw'] = avgbw(fullname, args, params)
            reslog = logs(fullname, "Utilization")
            with open(reslog, 'rb') as f:
                for line in f:
                    for header in summary_headers:
                        if header in line:
                            table[header] = getUtil(line)

def futil(used,total):
   return round(float(used) / float(total), 3)

def bestSummary():
    best = OrderedDict()
    best['TPCHQ6'] = ('TPCHQ6_96000_outerPar_8_tileSize_2000', '96000')
    best['BlackScholes'] = ('BlackScholes_1966080_outerPar_1_tileSize_32768', '1966080')
    best['Kmeans_plasticine'] = ('Kmeans_plasticine_1_6144_tileSize_512', '1_6144')
    best['SPMV_CRS'] = ('SPMV_CRS__tileSize_208_tile_par_2_pt_par_1', '')
    best['GEMM_Blocked'] = ('GEMM_Blocked__tileSize_256_i_tileSize_256_loop_jj_1_loop_ii_1_loop_kk_1_loop_i_4_loop_k_3', '')
    best['GDA'] = ('GDA_38400_tileSize_1600_outerPar_6_midPar_1', '38400')

    headers = ['App', 'lavgbw', 'savgbw', 'pcuUtil', 'mcuUtil', 'mcUtil', 'totalFUUtil']
    with open(BEST_SUMMARY_CSV_PATH, 'w') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=headers)
        writer.writeheader()
        for app in best:
            dict = {'App':app }
            for header in headers:
                fullname, args = best[app]
                if header == 'App':
                    pass
                elif header in ['lavgbw', 'savgbw']:
                    dict[header] = round(summary[app][args][fullname][header] / max_bw * 100, 2)
                elif header not in ['cycle']:
                    used, total = summary[app][args][fullname][header]
                    dict[header] = futil(used, total) * 100
                else:
                    dict[header] = summary[app][args][fullname][header]
            writer.writerow(dict)

def summaryToCsv():
    global summary
    with open(SUMMARY_CSV_PATH, 'w') as csvfile:
        writer = csv.DictWriter(csvfile, fieldnames=summary_headers)
        writer.writeheader()
        for app in summary:
            for arg in summary[app]:
                for fullname in summary[app][arg]: 
                    dict = {'App':fullname}
                    for header in summary[app][arg][fullname]:
                        if header not in ['App', 'cycle', 'lavgbw', 'savgbw']:
                            used, total = summary[app][arg][fullname][header]
                            dict[header] = futil(used, total)
                        elif header in ['lavgbw', 'savgbw']:
                            dict[header] = round(summary[app][arg][fullname][header], 3)
                        else:
                            dict[header] = summary[app][arg][fullname][header]
                    writer.writerow(dict)


def target(app, args, params):
    if opts.run:
        runApp(app, args, params)
    elif opts.status:
        status(app, args, params)
    elif opts.summary:
        summarize(app, args, params)

def dse(app, args, params):
    # print(params)
    for param in params:
        # print('  param:' + param + ' = ' + str(params[param]))
        if type(params[param]) is list:
            if len(params[param])==0:
                return 0
            newParams = params.copy()
            cnt = 0
            if opts.single:
                params[param] = [params[param][0]]
            for val in params[param]:
                newParams[param] = val
                cnt += dse(app, args, newParams)
            return cnt
        elif type(params[param]) is types.LambdaType:
            newParams = params.copy()
            newParams[param] = params[param](params)
            return dse(app, args, newParams)
        else:
            continue
    print('{}{} args={} and params=[{}]{}'.format(bcolors.UNDERLINE, app, str(args),
        ' '.join(['{}={}'.format(p,params[p]) for p in params]), bcolors.ENDC))
    target(app, args, params)
    return 1

def irange(start, stop, step):
    r = range(start, stop, step)
    if (len(r)>0):
        last = r[-1]
    else:
        last = start
    if(last+step==stop):
        r.append(stop)
    return r

def addArgs(app, args):
    if opts.summary:
        if sargs(args) not in summary[app]: 
            summary[app][sargs(args)] = OrderedDict()

# tucson
def TPCHQ6():
    app = 'TPCHQ6'
    space = 0
    N = 96000
    args = [N]
    addArgs(app, args)

    # FINISHED
    params = OrderedDict()
    params['outerPar'] = irange(1, 10, 2) 
    params['tileSize'] = lambda params: irange(3000, min(bankSize, N/params['outerPar']/4), 3000)
    space += dse(app, args, params)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(6, 10, 2) 
    params['tileSize'] = lambda params: irange(400, min(bankSize, N/params['outerPar']/4), 800)
    space += dse(app, args, params)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(2, 10, 2) 
    params['tileSize'] = lambda params: irange(16, min(bankSize, N/params['outerPar']/200), 16*2)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# tucson
def GDA():
    app = 'GDA'
    space = 0

    # R = 192000
    # MAXC = 80
    # args = [R]
    # addArgs(app, args)

    # # Finished 
    # params = OrderedDict()
    # # params['tileSize'] = irange(16, 16*5, 16) 
    # params['tileSize'] = irange(16, bankSize*lanes/MAXC, 512) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 
    # space += dse(app, args, params)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(16, 16*3, 16*2) 
    # params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    # params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 
    # space += dse(app, args, params)

    # # portland
    # R = 19200
    # MAXC = 80
    # args = [R]
    # addArgs(app, args)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(1024, bankSize*lanes/MAXC, 1024) 
    # params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    # params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 
    # space += dse(app, args, params)

    # # Finished 
    # params = OrderedDict()
    # params['tileSize'] = irange(1024, bankSize*lanes/MAXC, 1024) 
    # params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    # params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 
    # space += dse(app, args, params)

    R = 38400 
    MAXC = 96
    args = [R]
    addArgs(app, args)
    params = OrderedDict()
    params['tileSize'] = 1600
    params['outerPar'] = 6
    params['midPar'] = 1 
    space += dse(app, args, params)
    print('{} space: {}'.format(app, space))

# london
def GEMM_Blocked():
    app = 'GEMM_Blocked'
    space = 0
    dim = 512
    # args += [dim]
    args = []
    addArgs(app, args)

    params = OrderedDict()
    params['tileSize']   = [16, 256] # irange(16, dim, 16)
    params['i_tileSize'] = [16, 256] # irange(16, dim, 16)
    params['loop_jj']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_ii']    = lambda params: irange(1 , min(dim/params['i_tileSize'], 2), 1)
    params['loop_kk']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_i']     = lambda params: irange(1 , min(params['i_tileSize']    , 2), 1)
    params['loop_k']     = lambda params: irange(1 , min(params['tileSize']      , 2), 1)
    space += dse(app, args, params)

    params = OrderedDict()
    params['tileSize']   = [256] # irange(16, dim, 16)
    params['i_tileSize'] = [256] # irange(16, dim, 16)
    params['loop_jj']    = 1 
    params['loop_ii']    = 1
    params['loop_kk']    = 1
    params['loop_i']     = [1,2,3,4,5]
    params['loop_k']     = [1,2,3,4,5]
    space += dse(app, args, params)
    print('{} space: {}'.format(app, space))

# london
def BlackScholes():
    app = 'BlackScholes'
    space = 0
    N = 1966080  
    args = [N]
    addArgs(app, args)

    # Finished
    params = OrderedDict()
    params['outerPar'] = irange(1, 4, 1) 
    params['tileSize'] = lambda params: irange(1024, min(bankSize, N/params['outerPar']), 1024)
    space += dse(app, args, params)

    params = OrderedDict()
    params['outerPar'] = 1 
    params['tileSize'] = lambda params: irange(1024*16, min(bankSize*lanes,N/params['outerPar']),1024*16)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

def PageRank_plasticine():
    app = 'PageRank_plasticine'
    space = 0
    iters = 1
    NP = 491520 # 2048 in simulation
    damp = 0.125
    args = [iters, NP, damp]
    addArgs(app, args)

    params = OrderedDict()
    maxTile = min(bankSize*lanes,NP)
    params['tileSize'] = [16, 1024, 1024*6, maxTile/4, maxTile/2, maxTile] 
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# london
def Kmeans_plasticine():
    app = 'Kmeans_plasticine'
    space = 0
    iter = 1
    N = 6144
    dim = 96
    args = [1, N]
    addArgs(app, args)

    # Finished 
    params = OrderedDict()
    params['tileSize'] = irange(16, 16, 1) + irange(128, 512, 128) + irange(1024,min(bankSize*lanes/dim, N), 1024)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

# tucson
def SPMV_CRS():
    app = 'SPMV_CRS'
    space = 0
    N = 494
    args = []
    addArgs(app, args)

    params = OrderedDict()
    maxTile = min(bankSize*lanes, N)
    # Finished
    params['tileSize'] = irange(16, maxTile, 64) 
    params['tile_par'] = lambda params: irange(1, min(5, N/params['tileSize']), 1)
    params['pt_par'] = lambda params: irange(1, min(5, params['tileSize']), 1)
    space += dse(app, args, params)

    print('{} space: {}'.format(app, space))

def expRun():
    #################################################################################################################
    ###                                                ASPLOS 2018                                           ########
    #################################################################################################################

    ### TO RUN        ######################################################################################################
    app = opts.app

    if app in ['TPCHQ6', 'ALL']:
        TPCHQ6()
    if app in ['GDA', 'ALL']:
        GDA()
    if app in ['GEMM_Blocked', 'ALL']:
        GEMM_Blocked()
    if app in ['BlackScholes', 'ALL']:
        BlackScholes()
    if app in ['Kmeans_plasticine', 'ALL']:
        Kmeans_plasticine()
    if app in ['PageRank_plasticine', 'ALL']:
        PageRank_plasticine()
    if app in ['SPMV_CRS', 'ALL']:
        SPMV_CRS()

def main():
    parser = argparse.ArgumentParser(description='Run experiments')
    parser.add_argument('--parallel', dest='parallel', action='store_true', default=False) 
    parser.add_argument('--single', dest='single', action='store_true', default=False) 
    parser.add_argument('--run', dest='run', action='store_true', default=False) 
    parser.add_argument('--status', dest='status', action='store_true', default=False) 
    parser.add_argument('--clearAll', dest='clearAll', action='store_true', default=False) 
    parser.add_argument('--app', dest='app', action='store', default='DotProduct',help='App name')
    parser.add_argument('--regen', dest='regen', action='store', default='false',
        help='force pass to rerun' )
    parser.add_argument('--torun', dest='torun', action='store', default='ALL',
        help='Pass to run')
    parser.add_argument('--summary', dest='summary', action='store_true', default=False) 
    parser.add_argument('--best', dest='best', action='store_true', default=False) 
    parser.add_argument('--plot', dest='plot', action='store_true', default=False) 
    parser.add_argument('--plot_fpga', dest='plot_fpga', action='store_true', default=False) 

    global opts
    (opts, args) = parser.parse_known_args()

    os.chdir(SPATIAL_HOME)
    if not os.path.exists('{}/gen'.format(SPATIAL_HOME)):
        os.makedirs('{}/gen'.format(SPATIAL_HOME))
    global job_list
    if not os.path.exists(JOB_PATH):
        job_list = [] 
        print('New job list!')
    else:
        job_list = pickle.load(open(JOB_PATH, 'rb'))
        checkProcess()
        print("Number of active jobs({})={}".format(len(job_list), job_list))

    if opts.summary or opts.plot or opts.best:
        global summary
        if not os.path.exists(SUMMARY_PATH):
            print("New app summary at {}".format(SUMMARY_PATH))
            summary = OrderedDict()
        else:
            summary = pickle.load(open(SUMMARY_PATH, 'rb'))
        for app in apps:
            if app not in summary:
                summary[app] = OrderedDict()

    if opts.clearAll:
        clearAll()
    if opts.plot_fpga:
        plot_f1()
        plot_zynq()
    else:
        expRun()

    if opts.summary:
        pickle.dump(summary, open(SUMMARY_PATH, 'wb'))
        summaryToCsv()

    if opts.best:
        bestSummary()

    if opts.plot:
        plot()
    #################################################################################################################

if __name__ == "__main__":
    main()

