#!/usr/bin/env python

from os import listdir
from os.path import isfile, isdir, join, splitext, basename, dirname 
from collections import OrderedDict
import os
import argparse
import subprocess
import commands
import time
import pickle
import signal
import psutil
import shutil
import numpy as np
import types

lanes = 16
bankSize = 32 * 1024 / 4
proc_thresh = 15

SPATIAL_HOME = os.environ['SPATIAL_HOME']
PIRL_HOME = os.environ['PIR_HOME']
APP_DIR='{}/apps/src/'.format(SPATIAL_HOME)
JOB_PATH="{}/gen/job_list.pickle".format(SPATIAL_HOME)

class bcolors:
    HEADER = '\033[95m'
    OKBLUE = '\033[94m'
    OKGREEN = '\033[92m'
    WARNING = '\033[93m'
    FAIL = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def newAppName(app, args, params):
    postfix = '_'.join([str(a) for a in args])
    postfix = postfix + ''.join(["_{}_{}".format(k,str(params[k])) for k in params ]) 
    newname = '{}_{}'.format(app, postfix)
    newname = newname.replace('.','d')
    return newname

def copyApp(app, args, params):
    path = '{0}/{1}.scala'.format(APP_DIR, app)
    newname = newAppName(app, args, params) 
    if not os.path.exists('{}/gen'.format(APP_DIR)):
        os.makedirs('{}/gen'.format(APP_DIR))
    newpath = '{0}/gen/{1}.scala'.format(APP_DIR, newname)
    paramFound = {}
    with open(newpath, 'w') as newapp:
        with open(path, 'r') as origapp :
            for line in origapp:
                found = False
                if 'object {}'.format(app) in line:
                    newapp.write(line.replace(app, newname))
                    found = True
                for param in params:
                    if 'val {} = '.format(param) in line:
                        newapp.write('val {} = {}\n'.format(param, params[param]))
                        paramFound[param] = True
                        found = True
                if not found:
                    newapp.write(line)
    for param in params:
        if param not in paramFound:
            print('Param {} not found !!!'.format(param))
            exit()

def checkProcess():
    for pid in job_list:
        if not os.path.exists("/proc/{}".format(pid)):
            job_list.remove(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))

def waitProcess():
    checkProcess()
    if len(job_list) > proc_thresh:
        time.sleep(5)
        waitProcess()

def runApp(app, args, params):
    if opts.parallel:
        waitProcess()
        signal.signal(signal.SIGCHLD, signal.SIG_IGN)
    copyApp(app, args, params)
    newname = newAppName(app, args, params)
    command = "apps/bin/runapp {} {} {} {}".format(newname, ' '.join([str(a) for a in args]),
            opts.torun, opts.regen)
    print('command={}'.format(command))
    proc = subprocess.Popen(command.split(), shell=False)
    pid = proc.pid
    job_list.append(pid)
    pickle.dump(job_list, open(JOB_PATH, 'wb'))
    if opts.parallel:
        time.sleep(1)
    else:
        proc.wait()

def clear(app, args, params):
    newname = newAppName(app, args, params)
    command = "rm -r gen/{}/Top.vcd".format(newname)
    print(command)
    subprocess.call(command, shell=True)

def clearAll():
    dirs = [join('gen', d) for d in listdir('gen') if isdir(join('gen', d))]
    for d in dirs:
        files = [join(d, f) for f in listdir(d) if f != 'sim.log']
        for f in files:
            print('removing {}'.format(f))
            if isdir(f):
                shutil.rmtree(f)
            elif isfile(f):
                os.remove(f)
            
count = 0
def status(app, args, params):
    global count
    newname = newAppName(app, args, params)
    command = "apps/bin/status {}".format(newname)
    print(command)
    proc = subprocess.Popen(command, shell=True)
    proc.wait()
    # raw_input("status[{}]: Press Enter to continue...\n".format(count))
    count += 1
    # proc.kill()

def target(app, args, params):
    if opts.run:
        runApp(app, args, params)
    elif opts.status:
        status(app, args, params)

def dse(app, args, params):
    # print(params)
    for param in params:
        # print('  param:' + param + ' = ' + str(params[param]))
        if type(params[param]) is list:
            if len(params[param])==0:
                return 0
            newParams = params.copy()
            cnt = 0
            if opts.single:
                params[param] = [params[param][0]]
            for val in params[param]:
                newParams[param] = val
                cnt += dse(app, args, newParams)
            return cnt
        elif type(params[param]) is types.LambdaType:
            newParams = params.copy()
            newParams[param] = params[param](params)
            return dse(app, args, newParams)
        else:
            continue
    print('{}{} args={} and params=[{}]{}'.format(bcolors.UNDERLINE, app, str(args),
        ' '.join(['{}={}'.format(p,params[p]) for p in params]), bcolors.ENDC))
    target(app, args, params)
    return 1

def irange(start, stop, step):
    r = range(start, stop, step)
    if (len(r)>0):
        last = r[-1]
    else:
        last = start
    if(last+step==stop):
        r.append(stop)
    return r


apps = ['DotProduct', 'TPCHQ6', 'GDA', 'BlackScholes', 'Kmeans_plasticine', 'PageRank_plasticine', 'SPMV_CRS', 'GEMM_Blocked']

def TPCHQ6(args, params):
    N = 96000
    args += [N]

    # FINISHED
    params['outerPar'] = irange(1, 10, 2) 
    params['tileSize'] = lambda params: irange(3000, min(bankSize, N/params['outerPar']/4), 3000)

    # Finished
    # params['outerPar'] = irange(6, 10, 2) 
    # params['tileSize'] = lambda params: irange(400, min(bankSize, N/params['outerPar']/4), 800)

    # Finished
    # params['outerPar'] = irange(2, 10, 2) 
    # params['tileSize'] = lambda params: irange(16, min(bankSize, N/params['outerPar']/200), 16*2)

def GDA(args, params):
    R = 192000
    MAXC = 80
    args += [R]

    # Finished 
    # params['tileSize'] = irange(16, 16*5, 16) 
    params['tileSize'] = irange(16, bankSize*lanes/MAXC, 512) 
    params['outerPar'] = lambda params: irange(1, min(10, R/params['tileSize']), 3) 
    params['midPar'] = lambda params: irange(1, min(8, params['tileSize']), 3) 

    # Finished 
    # params['tileSize'] = irange(16, 16*3, 16*2) 
    # params['outerPar'] = lambda params: irange(2, min(6, R/params['tileSize']), 2) 
    # params['midPar'] = lambda params: irange(2, min(6, params['tileSize']), 2) 

def GEMM_Blocked(args, params):
    args += []
    dim = 512

    params['tileSize']   = [16, 256] # irange(16, dim, 16)
    params['i_tileSize'] = [16, 256] # irange(16, dim, 16)
    params['loop_jj']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_ii']    = lambda params: irange(1 , min(dim/params['i_tileSize'], 2), 1)
    params['loop_kk']    = lambda params: irange(1 , min(dim/params['tileSize']  , 2), 1)
    params['loop_i']     = lambda params: irange(1 , min(params['i_tileSize']    , 2), 1)
    params['loop_k']     = lambda params: irange(1 , min(params['tileSize']      , 2), 1)

def BlackScholes(args, params):
    N = 1966080  
    args += [N]

    # Finished
    # params['outerPar'] = irange(1, 4, 1) 
    # params['tileSize'] = lambda params: irange(1024, min(bankSize, N/params['outerPar']), 1024)

    # TODO: make vcs
    params['outerPar'] = 1 
    params['tileSize'] = lambda params: irange(1024*16, min(bankSize*lanes,N/params['outerPar']),1024*16)

def PageRank_plasticine(args, params):
    N = 1966080  
    args = [N]
    pass

def Kmeans_plasticine(args, params):
    iter = 1
    N = 6144
    dim = 96
    args += [1, N]

    # Finished 
    params['tileSize'] = irange(16, 16, 1) + irange(128, 512, 128) + irange(1024,min(bankSize*lanes/dim, N), 1024)

def expRun():
    #################################################################################################################
    ###                                                ASPLOS 2018                                           ########
    #################################################################################################################

    ### TO RUN        ######################################################################################################
    params = OrderedDict()
    args = OrderedDict()
    for app in apps:
        params[app] = OrderedDict()
        args[app] = []

    app = opts.app

    TPCHQ6(args['TPCHQ6'], params['TPCHQ6'])
    GDA(args['GDA'], params['GDA'])
    GEMM_Blocked(args['GEMM_Blocked'], params['GEMM_Blocked'])
    BlackScholes(args['BlackScholes'], params['BlackScholes'])
    Kmeans_plasticine(args['Kmeans_plasticine'], params['Kmeans_plasticine'])

    space = dse(app, args[app], params[app])
    print('{} space: {}'.format(app, space))

def main():
    parser = argparse.ArgumentParser(description='Run experiments')
    parser.add_argument('--parallel', dest='parallel', action='store_true', default=False) 
    parser.add_argument('--single', dest='single', action='store_true', default=False) 
    parser.add_argument('--run', dest='run', action='store_true', default=False) 
    parser.add_argument('--status', dest='status', action='store_true', default=False) 
    parser.add_argument('--clearAll', dest='clearAll', action='store_true', default=False) 
    parser.add_argument('--app', dest='app', action='store', default='DotProduct',help='App name')
    parser.add_argument('--regen', dest='regen', action='store', default='false',
        help='force pass to rerun' )
    parser.add_argument('--torun', dest='torun', action='store', default='ALL',
        help='Pass to run')

    global opts
    (opts, args) = parser.parse_known_args()

    os.chdir(SPATIAL_HOME)
    global job_list
    if not os.path.exists(JOB_PATH):
        job_list = [] 
        print('New job list!')
    else:
        job_list = pickle.load(open(JOB_PATH, 'rb'))
        checkProcess()
        print("Number of active jobs({})={}".format(len(job_list), job_list))

    if opts.clearAll:
        clearAll()
    else:
        expRun()

    #################################################################################################################

if __name__ == "__main__":
    main()

